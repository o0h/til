# Refactoring by Martin Fowler

---
書籍:  
**新装版 リファクタリング 既存のコードを安全に改善する**  
がとてもお気に入りなので、  ちょっとしたご紹介をします。

---
## 今日の目的
* 「名著」「Martin Fowler」「新装版」「オーム社」という
* **とっつきにくい1冊** があるのですが

+++
![image](https://user-images.githubusercontent.com/907122/39283768-d2009d58-494a-11e8-9ffd-11e7bf9c062e.png)

+++
私も

* 硬そう
* 厚そう
* 表紙がとっつきづらそう
* 読んだら・・かっこいいんじゃない・・・

という気持ちで買いました！

+++
* ですが、間違いなく名著
* 意外と親しみやすい

-> みなさんにも、「怖くないね！！面白そう！！」ってなってもらえれば幸い

というのが今日のゴールです・・

+++ 
## 話すこと

1. どんな本ですか？
2. リファクタリングについての考え方
    * コードの不吉な臭い
3. パターンの紹介(5つ)

---
## どんな本ですか？
* この本はリファクタリングのガイドブックです
* 系統だった効果的なリファクタリング手法を説明していきます
* 第3章: コードの不吉な臭い
* 第5章-第12章: リファクタリング・カタログ

「問題」と「手法(パターン )」について一覧化した「カタログ」となる一冊。

+++
* 手法については、コード例はもちろん「動機」と「手順」が併記されている
    * 動機: 適用する理由、解決したい本質
    * 手順: いかに壊さないように整理するか、の作業手順

---
## リファクタリングってなんですか？

* ソフトウェアを「理解しやすく」「変更を容易にする」ために行うもの。
    * ソフトウェアは「劣化していく」という前提
    * 本書では「理解しにくくなる変更」とは別に考えている
    * ex: パフォーマンス・チューニング
* **外的振る舞いを保ったまま**、内部に変更をくわえること

+++
### 2つの帽子
* 「機能追加」と「リファクタリング」を区分して考えよう
* 「機能追加」の時にはテストを追加し、既存コードは変更しない
* 「リファクタリング」の時には機能追加をせず、(原則として)テストの追加をしない

+++
### 小さなリファクタリングと大きなリファクタリング
* リファクタリングは、数分〜数時間で達成できるものと数ヵ月以上を要するものがある
* 後者は、全体の「ゲーム」に対する変更
    * 継承の切り離し(not 分割)
    * パラダイムの変更(ex: 手続き的 → オブジェクト指向的、 VC →  MVC)
    * など
+++
今日の話は「小さなリファクタリング」メイン！

---
## リファクタリングのすすめ
リファクタリング作業の主作用は「設計がより良くなる」こと。  
加えて、以下のような作用もある

+++
* リファクタリングは既存コードへの理解を深める
    * `私はリファクタリングをコードの不明な部分を理解するのに使うことがあります`

+++
* リファクタリングはバグを見つけ出す
    * プログラムの構造を明確に、コードに対する「推測」が正解が見える

+++
* リファクタリングはプログラミングを速くする
    * 設計の劣化を防ぎ、より良い設計によって従来より高速な開発が可能になる

---
## 私とリファクタリング
* 個人的に **良いコード** とは、**リファクタブルなコード**のことだと思う
* リファクタは「過去のコードを、現在や未来へと転生させる」行為
    * リファクタしづらい = 沈み行く船

+++
* つまり「リファクタブルである」ことは「まだ前線で戦える」ことを保証する
* 設計が明瞭であり、意図のあるコード。「何をして何をしていないか」を語りかけてくるコード。

---
## リファクタリングと不吉な臭い
* リファクタリングをしよう！というきっかけは？(対象は？)
    * Kent Beck 「コードの不吉な臭い」

```
コードの臭い（こーどのにおい、英: Code smell）とは、コンピュータプログラミングにおいてプログラムのソースコードに深刻な問題が存在することを示す何らかの兆候のことを言う。
コードの臭いが示す深刻な問題は、小さく管理された手順でリファクタリングする短いフィードバックサイクルを廻し、それ以上のリファクタリングが必要なことを示すコードの臭いがないかどうか、設計を検査しなければならない。
リファクタリングを実施するプログラマの視点からは、コードの臭いはいつリファクタリングするか、どのリファクタリング手法を用いるか、発見するための方法である。すなわち、リファクタリングを後押しするものである。
```

+++
## 不吉な臭いとは・・？(第3章)
(1/4)
* 重複したコード
* 長すぎるメソッド
* 巨大なクラス
* 長すぎるパラメータリスト
* 変更の偏り
* 変更の分散

+++
(2/4)
* 特性の横恋慕
* データの群れ
* 基本データがへの執着
* スイッチ文
* パラレル継承
* 怠け者クラス

+++
(3/4)
* 疑わしき一般化
* 一時的属性
* メッセージの連鎖
* 仲介人
* 不適切な関係
* クラスのインターフェース不一致

+++
(3/4)
* 未熟なクラスライブラリ
* データクラス
* 相続拒否
* コメント

+++
## 不吉な臭いと攻略法
本書は「リファクタリング手法のカタログ」であり、  
それぞれ「不吉な臭い」と対応させて説明がされてるのです！(素敵++)

* ex: 「長すぎるメソッド」
    * -> 条件記述の分解, 問い合せによる一時変数の置き換え

+++ 
### 不吉な臭いとパターンの逆引き表

[![img_3632](https://user-images.githubusercontent.com/907122/39220939-3af89bda-486f-11e8-94cf-7aaaa0e924c9.JPG)](https://user-images.githubusercontent.com/907122/39220939-3af89bda-486f-11e8-94cf-7aaaa0e924c9.JPG)

+++
[![img_3653](https://user-images.githubusercontent.com/907122/39220940-3b2e4e42-486f-11e8-845a-c95bef0d2b79.jpg)](https://user-images.githubusercontent.com/907122/39220940-3b2e4e42-486f-11e8-845a-c95bef0d2b79.jpg)

+++
* 「セットで考える」のが大事。意識をする
* それによって「必要性」や「どう対処するか」がパターン化される
* 「パターン化」 = 公式化、当たり前化。脳みそCPUを抑えつつ、解答を出すこと。

+++
* リファクタリング怖くない！！
* リファクタリング大好き！！
* やった〜〜！リファクタリングだ！！

脳になりましょう＼(^o^)／

---
## いつリファクタリングをするのか？
時間を決めて行う！というものではなく、「必要に応じて」行うべき。

+++
* 機能追加のときに
    * 「コードへの理解を深める」ためのリファクタ
    * 拡張性の「追加」要請や「除去」に耐えうるように

+++
* バグフィックスのときに
    * 「コードへの理解を深める」ためのリファクタ
    * バグレポート自体が「要リファクタリング」のシグナルという見方も

+++
* コードレビューのときに
    * 「コードへの理解を深める」ためのリファクタ
    * レビュアーが、レビュー時にリファクタを行って(実装者に)提案するやり方
    * 複数の視点・アイディアをコードに取り込める

---
## 実践

---
先程「リファクタはいつやるべきか」を紹介しました

+++
が、もっと「日常的に」リファクタと実践するのが良いのでは？

+++
* ローカルでの開発のサイクル(=PRを投げる前)に、「リファクタリング」を組み込む
* テストを書いたあとに「リファクタリング」を行う
* レビュー時に「リファクタリング」目線でフィードバックをする

+++
## TDDとリファクタリング
* TDDのリズム
    * レッド， グリーン， **リファクタリング**

+++
### 言い換えれば・・
* レッド: 仕様の記述
* グリーン: 「機能追加」の帽子をかぶる
* リファクタリング: 「リファクタリング」の帽子をかぶる

とも言えるかもしれない・・・？

+++
(個人的には)  
「実装する」と「整える」を別々にやってる。  
-> セルフレビューの強制・強化

(ついでにrebaseしてコミットも整えつつ)

+++
![image](https://user-images.githubusercontent.com/907122/39256442-e142be42-48e9-11e8-864f-ffc22b66fd41.png)

+++
![image](https://user-images.githubusercontent.com/907122/39256455-ebb2893e-48e9-11e8-87f5-48b99ffb266c.png)

+++
![image](https://user-images.githubusercontent.com/907122/39256467-f39a29ea-48e9-11e8-83ff-c517d21cd463.png)

+++
![image](https://user-images.githubusercontent.com/907122/39256484-fccdc918-48e9-11e8-869d-d8687b6cf816.png)

---
## リファクタリングパターンを一部紹介！！

+++
* スライド上でも紹介しやすそうなのを、独断で選んで取り上げます
* 「いつものアレ」に「名前」と「動機」が言語化されていることを感じてください！
* その結果、本書の魅力を感じてください！

+++
### ちなみに
* https://refactoring.com/catalog/ にあります！
* 以下、キャプチャはこちらの画像を利用したもの

---
### ガード説による入れ子条件記述のおき

![image](https://user-images.githubusercontent.com/907122/39281417-6bfc47ba-493f-11e8-9e27-58324d18d974.png)

+++
#### 内容
* 臭い: メソッド内に正常ルートが不明確な条件付き振る舞いがある
* やること: 特殊ケース全てに対してガード節を使う

+++
#### 動機
* 条件記述には2つの形式があり、目的が異なる
    1. 条件判定の両方が正常処理のケース
    2. 片方が正常で、もう片方がそうではないケース
* 「目的」をはっきりさせる

---
### メソッドの抽出

![image](https://user-images.githubusercontent.com/907122/39281553-3e72ed70-4940-11e8-8cb0-f95d28ec7f74.png)

+++
#### 内容
* 臭い: 長すぎるメソッド
    * ひとまとめにできるコードの断片がある
* やること:
    1. コードの断片をメソッドにして
    2. それに目的を表すような名前をつける

+++
#### 動機
* メソッドの粒度を細かくできると再利用性があがる
* メソッド名によって、コメントの代わりのような役割が担われる
    * _(メソッドの)長さではなく、「意味的な距離」が重要_
    * 小さなメソッドは、いい名前がつけられなければ有効ではない

---
### メソッドのインライン化
#### inverse of Extract Method

![image](https://user-images.githubusercontent.com/907122/39282218-6f6a0db6-4943-11e8-9453-7251ef8a346d.png)

+++
#### 内容
* 臭い: 仲介人(過剰な分割、メッセージングの複雑化)
    * メソッドの本体が、名前をつけて呼ぶまでもなく明らか
* やること: メソッドの実装内容を本体の中にインライン化して埋め込む

+++
#### 動機
* 「名前がわかりにくい」「名前をつけて呼ぶまでもない」ような処理の切り出しは、「間接化の失敗」
* 不要な間接化はわずらわしい！
* 「うまく取り出されていない」と感じるメソッドをインライン化し、改めて整理した上で抽出するのも有効
    * メソッドの抽出
    * [メソッドオブジェクトによるメソッドの置き換え](https://refactoring.com/catalog/replaceMethodWithMethodObject.html)

---
### 表明の導入

![image](https://user-images.githubusercontent.com/907122/39282290-b6a0e362-4943-11e8-8107-97f222fca577.png)

+++
#### 内容
* 臭い: コメント(コメントが多い = わかりにくいコードかもという黄信号)
    * コードのある部分が、(状態についての)前提事項を持っている
* やること:
    * コメントで選定事項を説明する代わりに、表明を用いる

+++
#### 動機
* 前提事項がコメントで説明されているのは良いこと
    * コードを辿らなくて良くなる
* とはいえ、コメントは実装を「失敗」させてくれない
* 表明(アサーション)を用いてfail fastに！

---
### クラスの抽出

![image](https://user-images.githubusercontent.com/907122/39282517-a25face8-4944-11e8-90e2-26c4fdbf6650.png)

+++
#### 内容
* 臭い: 変更の偏り(1つのクラスが別々の理由で何度も変更される, anti-SRP)
    * nつのクラスでなられるべき作業を1つのクラスで行っている
* やること: クラスを新設し、関連するフィールド&メソッドを移動する

+++
#### 動機
* 大きすぎてかんたんに理解できないクラスがある
    * 特に「クラスが成長して」陥ることも多い！
* データやロジック自体の難読化・複雑化や、影響範囲の不透明化を限定する

---

こんな感じで、約80パターンあるよ！！

---
## ご清聴ありがとうございました

* 個人的に、「良いコードって何」という価値観を身につける上で刺激になった1冊
* 分量はあるので、450ページ通読しようとすると大変かも
* 第3章まで読んで、「カタログ」もしくは「逆引き対応表」から摘み食いするの面白いかも

+++
![image](https://user-images.githubusercontent.com/907122/39284303-86511ce0-494d-11e8-8307-467d3f056e77.png)

みんなで、  
「線引がはっきりしていて」「意図の明確」な  
実装を頑張りましょう！！


